# Тестовое задание

## C#

**Вопрос 1.
Сколько разрядов может содержать в себе тип в `int`?**

**Ответы:**

1.	64
2.	32
3.	Зависит от машины, на которой производилась компиляция
4. 16

**Вопрос 2.
Есть код вида:**

```csharp
Nullable<int> a = 456789;
int b = (int)a;
Console.WriteLine(b);
```

**Что произойдет на второй строчке?**

**Ответы:**

1. Копирование ссылки на объект из переменной  `a` в переменную `b`
2. Распаковка значения и копирования значения переменной
3. Копирование значения переменной
4. Ошибка на этапе выполнения

**Вопрос 3. Есть следующий код.**

```csharp
var stream = new StreamWriter(@"c:\Temp\1.txt");
stream.Write("test");

var stream2 = new StreamReader(@"c:\Temp\1.txt");
var str = stream2.ReadToEnd();

Console.WriteLine(str);
Console.ReadKey();
```

**Исходим из того что файла на диске изначально нет и на первой строке ошибки не будет, если файла на диске нет, он создастся:**

**Что произойдет с этим кодом?**

**Ответы:**

1.	Будет выведена строка `test` в консоли на экран
2.	Будет выведена пустая строка в консоли на экране
3.	Будет сформировано исключение на этапе выполнения в строке (3)
4.	Будет выведено имя типа в консоли на экране

**Вопрос 4.
Ниже представлен код. Выберите, один из вариантов ответов, что в итоге будет в переменной `finalProduct`.**

```csharp
	public sealed class Product
	{
		public Product()
		{
			ProductId = Guid.NewGuid();
		}

		public Guid ProductId { get; set; }

		public string Name { get; set; }

		public decimal Price { get; set; }
	}

	static void Main(string[] args)
	{
		var product = new Product
		{
			Name = "Product1",
			Price = 100
		};

		var serializer = new XmlSerializer(typeof(Product));

		string stringProduct;
		using (var memoryStream = new MemoryStream())
		using (var sr = new StreamReader(memoryStream))
		{
			serializer.Serialize(memoryStream, product);

			memoryStream.Position = 0;
			stringProduct = sr.ReadToEnd();
		}
			
		Product finalProduct;
		using (var sr = new StringReader(stringProduct))
		{
			finalProduct = (Product)serializer.Deserialize(sr);
		}

		Console.ReadKey();
	}
```

**Ответы:**

1.	В переменной `finalProduct` будет ссылка на объект в памяти на который ссылается переменная `product`, значение свойства `ProductId` будет совпадать 
2.	В переменной `finalProduct` будет ссылка на объект в памяти на который ссылается переменная `product`, значение свойства `ProductId` будет новое
3.	В переменной `finalProduct` будет ссылка на новый объект в памяти, значение свойства `ProductId`, будет новое
4.	В переменной `finalProduct` будет ссылка на новый объект в памяти, значение свойства `ProductId`, будет таким же как у объекта `product`

**Вопрос 5.
Ниже пример кода.**

```csharp
public void SerializeObjectGraph(FileStream fs, IFormatter formatter, Object rootObj)
{
	// Сохранение текущей позиции в файле
	Int64 beforeSerialization = fs.Position;
	try
	{
		// Попытка сериализовать граф объекта и записать его в файл
		formatter.Serialize(fs, rootObj);
	}
	catch
	{
		fs.Position = beforeSerialization;
		fs.SetLength(fs.Position);
        throw;
	}
}
```

**Корректно ли поведение данного метода с точки зрения правильного подхода к работе с исключениями?**

**Ответы:**

1.	Да, корректно
2.	Нет, тут идет перехват всех исключений, чего категорически делать не следует
3.	Нет, в данном случае вообще нельзя перехватывать исключение и обязательно оставить эту ситуацию на усмотрение кода, вызывающего данный метод
4.	Нет, в данном коде ошибка в секции `catch` нужно убрать инструкцию `throw`

## БД

**Вопрос 1.	
В базе данных имеются две таблицы – `Students` и `Results`.**

**В таблице `Students`**
* столбец `ID` – номер студенческого билета, первичный ключ
* столбец `Name` содержит ФИО студента.

**В таблице Results**
* поле ID – номер студенческого билета, внешний ключ, ссылающийся на таблицу `Students`
* Mark – оценка студента за экзамен; первичный ключ таблицы составной, он включает поля `ID`, `Subject`.

 **Из приведенных вариантов запросов выберите те, которые позволяют отобрать ФИО студентов, сдавших хотя бы 1 экзамен на 5.**

```sql
1.	SELECT DISTINCT Name FROM Students Left Join Results On Students.ID=Results.ID WHERE Mark<=5;
2.	SELECT DISTINCT Name FROM Students, Results WHERE Students.ID=Results.ID AND Mark=5;
3.	SELECT DISTINCT Name FROM Students WHERE ID In (Select ID From Results where Mark>5);
4.	SELECT DISTINCT Name FROM Students Inner Join Results On Students.ID=Results.ID WHERE Mark=5;
```

**Вопрос 2.
В базе данных имеется таблица `Book` со следующими столбцами:**

* `ID` – уникальный числовой идентификатор издания, первичный ключ
* `Title` – название книги
* `Author` – автор книги (принимаем допущение, что у каждой книги только один автор)
* `Publisher` – издательство, в котором вышла книга
* `Pub_Year` – год издания книги

| ID | Title | Author | Publisher | Pub_Year |
|----|-------|--------|-----------|----------|
| 1 |	Война и мир |              	Толстой Л.Н	| Мысль |           	1981 |
| 2 |	Казаки |                  	Толстой Л.Н. |	Азбука |           	1999 |
| 3 |	Французский язык |        	Исмаилов Р.А. |	Высшая школа |     	2003 |
| 4 |	Как это делалось в Одессе |	Бабель И. |	Азбука |           	2003 |


**Что произойдет при выполнении выражения `UPDATE Book SET ID=ID+1 WHERE Publisher = 'Азбука'`?**

1.	Обновление пройдет успешно для всех строк
2.	Синтаксис выражения UPDATE некорректен, поэтому оно даже не выполнится
3.	Выражение выполнится, но во время выполнения возникнет ошибка и ни одна строка не будет обновлена
4.	Обновится только одна строка, соответствующая книге «Как это делалось в Одессе»

 
**Вопрос 3.	
У вас есть таблица `People`, в ней 2 колонки `идентификатор записи(ID)` и `название(NAME)`**

| ID | NAME|
|----|-----|
| 1	| Иванов |
| 2	| Петров |
| 3	| Сидоров |
| 4	| Иванов |
| 5	| Петров |
| 6	| Петров |

**Напишите один запрос, который:**

1.	Выводит каждое неповторяющееся значение Name, 
2.	Выводит количество повторений значений Name
3.	В итоговую таблицу должны попасть только значения, которые имеют повторения

**Ожидаемый результат:**

| NAME | CNT |
|------|-----|
| ИВАНОВ | 2 |
| ПЕТРОВ | 3 |

**Вопрос 4.	
В базе данных имеется таблица `Book` со следующими столбцами:**

* `ID` – уникальный числовой идентификатор издания, первичный ключ
* `Title` – название книги
* `Author` – автор книги (принимаем допущение, что у каждой книги только один автор)
* `Publisher` – издательство, в котором вышла книга
* `Pub_Year` – год издания книги

Была создана таблица `Book1` с аналогичной структурой. Необходимо поместить в нее информацию обо всех книгах из `Book`, которые были изданы до 2000-го года. Выберите правильный вариант SQL-запроса.

```sql
1.	SELECT * INTO Book1 FROM Book WHERE Pub_Year<2000;
2.	SELECT * FROM Book WHERE Pub_Year<2000 TO Book1;
3.	INSERT INTO Book1 VALUES (SELECT * FROM Book WHERE Pub_Year<2000);
4.	INSERT INTO Book1 SELECT * FROM Book WHERE Pub_Year<2000;
```

**Вопрос 5.
Имеется таблица `Book`, в которой есть столбец `Author`. Ниже приведен запрос на языке SQL. Выберите из приведенного списка ответ, наиболее точно описывающий результат выполнения запроса.**
```sql
SELECT Author As A, 'Список авторов' As D FROM Book
```

1.	Результат выполнения запроса будет содержать 4 столбца;
2.	Результат выполнения запроса будет содержать 3 столбца;
3.	Результат выполнения запроса будет содержать 1 столбец;
4.	Будет получено сообщение о синтаксической ошибке;
5.	Результат выполнения запроса будет содержать 2 столбца.

## WPF

### Практическое задание напишите приложение `Курс валют` используя framework `Prism`

* Приложение должно загружать актуальный курс валют(с любого открытого сервиса) и отрисовывать в таблицу(грид)
* Иметь форму с калькулятором валют
    - ввели значение в одной валюте(пример доллар)
    - выбрали итоговую фалюту(пример рубль)
    - получили результат на форме(пример - 1$ = 39р)

* Иметь возможность хранить историю валют за последнии три дня(в БД).
